# vivado -mode batch -source script.tcl -tclargs "FPGA=115-2"
package require cmdline
package require try 

source common.tcl 

# Define command line options
set options {
    {f.arg "" "filename - .f file or .sv file"}
    {clk.arg 4.0 "target clock frequency"}
    {part.arg "xczu7ev-ffvc1156-2-e" "part number. Default = xczu7ev-ffvc1156-2-e (one of the free ZU+ boards)"}
    {top.arg "" "name of the top module to be synthesised"}
    {synth.arg "" "generic parameters - passed directly to synth design"}
    {run.arg "impl" "Run Vivado with options. synth and impl for out-of-context mode synthesis and implementation. bts for bitstream generation"}
}

set usage ": vivado.tcl \[options] filename ...\noptions:"
try {
    array set params [::cmdline::getoptions argv $options $usage]
} trap {CMDLINE USAGE} {msg o} {
    # Trap the usage signal, print the message, and exit the application.
    # Note: Other errors are not caught and passed through to higher levels!
    puts $msg
    exit 1
}

set part $params(part)
set files $params(f)
set top $params(top)
set clk $params(clk)
set output_dir build/$top
file mkdir $output_dir

# create_project [‑part <arg>] [‑force] [‑in_memory] [‑ip] [‑rtl_kernel][‑quiet] [‑verbose] [<name>] [<dir>]
create_project -part $part -in_memory -quiet $top $output_dir

# if -f option is used, use the file given in the option
# else check if synth.f file exists in the output directory - this is generated by the python script
if {[file extension $params(f)] eq ".f"} {
    read_f $params(f)
} elseif {$params(f) != ""} {
    # this option is only to run vivado.tcl directly
    read_rtl $params(f)
} elseif {[file exists $output_dir/synth.f]} {
    read_f $output_dir/synth.f
} else {
    puts "ERROR: no files loaded"
    puts $output_dir/synth.f
}

# if file type is .sv, add file to source files
# if input type is directory, add .v and .sv files in the directory
# if file type is .yaml, read the .yaml file

# synth_design [‑name <arg>] [‑part <arg>] [‑constrset <arg>] [‑top <arg>]
#  [‑include_dirs <args>] [‑generic <args>] [‑define <args>]
#  [‑verilog_define <args>] [‑vhdl_define <args>]
#  [‑flatten_hierarchy <arg>] [‑gated_clock_conversion <arg>]
#  [‑directive <arg>] [‑rtl] [‑lint] [‑file <arg>] [‑bufg <arg>] [‑no_lc]
#  [‑shreg_min_size <arg>] [‑mode <arg>] [‑fsm_extraction <arg>]
#  [‑rtl_skip_mlo] [‑rtl_skip_ip] [‑rtl_skip_constraints]
#  [‑srl_style <arg>] [‑keep_equivalent_registers]
#  [‑resource_sharing <arg>] [‑cascade_dsp <arg>]
#  [‑control_set_opt_threshold <arg>] [‑incremental_mode <arg>]
#  [‑max_bram <arg>] [‑max_uram <arg>] [‑max_dsp <arg>]
#  [‑max_bram_cascade_height <arg>] [‑max_uram_cascade_height <arg>]
#  [‑global_retiming <arg>] [‑no_srlextract] [‑assert] [‑no_timing_driven]
#  [‑sfcu] [‑debug_log] [‑rtl_block_model] [‑quiet] [‑verbose]

puts "running synth design"
puts $params(synth) 

set cmd "synth_design -top $top -mode out_of_context $params(synth)"
eval $cmd

# > $output_dir/synth.log
# this is assuming the clock port is declared as "clk" or starts with clk
if {[get_ports clk] != ""} {
    create_clock -name clk -period $clk [get_ports clk]
} else {
    puts "no clocks found"
}

puts "running opt design"
opt_design

puts "running place design"
place_design

puts "running route design"
route_design
write_checkpoint -force $output_dir/post_route.dcp

report_utilization -hierarchical > $output_dir/utilization.txt
